---
layout: default
title: 01 - HTTP request smuggling, basic CL.TE vulnerability
---
```HTTP
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED
```

**Frontend**
13 Bytes -> `0\r\n\r\nSMUGGLED`

**Backend**

Lee hasta 0r\n\r\n

SMUGGLED cuela como una nueva petici√≥n al backend


---

### üí• ¬øPor qu√© es esto peligroso?

#### 1. **Inyecci√≥n de solicitudes**

- El atacante puede "colar" la solicitud `SMUGGLED` sin que pase por filtros, firewalls, autenticaci√≥n, etc.
    
- Ejemplo: puede inyectar un `GET /admin` o `DELETE /user/123`.
    

#### 2. **Bypass de seguridad**

- El servidor front-end cree que solo pas√≥ una solicitud leg√≠tima.
    
- El servidor back-end procesa dos: una leg√≠tima y otra inyectada.
    

#### 3. **Secuestro de sesi√≥n**

- Si el contenido de `SMUGGLED` aprovecha cookies, sesiones u otros headers activos, puede acceder o modificar cosas sin autorizaci√≥n.
    

#### 4. **Cache poisoning**

- Puede envenenar el cach√© con respuestas maliciosas que luego otros usuarios reciben.
    

---


```http
POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

0

G
```

---

### üî¨ ¬øQu√© pasa realmente?

#### üîπ El **servidor front-end**:

- **No soporta `chunked encoding`**, por lo tanto **ignora el header `Transfer-Encoding: chunked`**.
    
- Solo interpreta `Content-Length: 6`.
    
- Entonces **considera el cuerpo de la solicitud como de solo 6 bytes**:
    
    ```
    0\r\n\r\nG
    ```
    
    Que son exactamente 6 bytes:
    
    - `0` ‚Üí 1 byte
        
    - `\r\n` ‚Üí 2 bytes
        
    - `\r\n` ‚Üí 2 bytes
        
    - `G` ‚Üí 1 byte  
        Total: 6 bytes
        
- Cree que el cuerpo termina ah√≠, y reenv√≠a TODO lo que sigue al servidor back-end.
    

---

#### üîπ El **servidor back-end**:

- **S√≠ interpreta `Transfer-Encoding: chunked`**, y ve que:
    
    - El chunk `0` indica que **termina la solicitud**.
        
    - Pero luego hay contenido sobrante:
        
        ```
        G
        ```
        
- Esto lo trata como **el inicio de la siguiente solicitud**:
    
    ```
    GPOST / HTTP/1.1
    ...
    ```
    
- En alg√∫n momento, el navegador, proxy o herramienta como Burp puede enviar una solicitud real `POST / HTTP/1.1...`, que se pegar√° justo despu√©s de la `G`, formando:  
    **`GPOST`** (una palabra malformada, pero detectada como una nueva petici√≥n inv√°lida).
    
---

Cuando reenviemos la solicitud del repeater, se enviar√° un GPOST, porque se concatenar√° la G con la segunda petici√≥n.

# **Acordarse de usar HTTP1.1**


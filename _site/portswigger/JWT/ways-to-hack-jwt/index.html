<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>M0B notes</title>
  <meta name="description" content="&lt;ol&gt;  &lt;li&gt;==Change Id==&lt;/li&gt;  &lt;li&gt;==Change algorithm to none/NONE/nOnE and send it without the signature==&lt;/li&gt;  &lt;li&gt;==Bruteforce the secret, using the original JWT whithout changes== : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashcat -a 0 -m 16500 &amp;lt;YOUR-JWT&amp;gt; /path/to/jwt.secrets.list&lt;/code&gt;Wordlist : &lt;strong&gt;/usr/share/SecLists/Passwords/jwt.secrets.list&lt;/strong&gt;&lt;strong&gt;/usr/share/SecLists/Passwords/scraped-JWT-secrets.txt&lt;/strong&gt;https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-weak-signing-keyPara luego firmar el token usar :  https://jwt.io/&lt;/li&gt;  &lt;li&gt;==Add embedded Header== in attack, change the name to administrator and click sign. Doing this we are sending to the server our public key, the server will use it to validate the token.&lt;/li&gt;  &lt;li&gt;==Via kid header path traversal== : The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kid&lt;/code&gt; (Key ID) parameter in a JWT header indicates which key the server should use for signature verification. By setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kid&lt;/code&gt; to a path traversal value like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;../../../../../../dev/null&lt;/code&gt;, we direct the server to look for a verification key in an invalid location. Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/dev/null&lt;/code&gt; is empty, the server fails to retrieve a key. Additionally, we generate a symmetric key with a null byte (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AA==&lt;/code&gt; in Base64) and use this key to sign the token. Due to improper key handling, the server may accept the token despite the invalid key, allowing unauthorized access.&lt;/li&gt;&lt;/ol&gt;">
  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="icon" href="/M0B.png" type="image/png">
  <style>
    /* fallback si la hoja no carga */
    body{background:#000;color:#e6e6e6;font:16px/1.7 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  </style>
  
  <script defer src="/assets/js/copy-code.js"></script>
</head>
<body>
  <header class="site-header">
    <div class="site-brand">
      <img class="brand-logo" src="/M0B.png" alt="logo" />
      <div class="brand-title">M0B notes</div>
    </div>
    <nav class="site-nav">
      <a href="/">Inicio</a>
      <a href="/puertos/">Puertos</a>
      <a href="/escalada/">Escalada</a>
      <a href="/portswigger/">Portswigger</a>
      <a href="/hackthebox/">HackTheBox</a>
      <a href="/real_life/">Real Life</a>
      <a href="/extras/">Extras</a>
    </nav>
  </header>

  <main>
    <div class="container">
      <ol>
  <li>==Change Id==</li>
  <li>==Change algorithm to none/NONE/nOnE and send it without the signature==</li>
  <li>==Bruteforce the secret, using the original JWT whithout changes== : 
<code class="language-plaintext highlighter-rouge">hashcat -a 0 -m 16500 &lt;YOUR-JWT&gt; /path/to/jwt.secrets.list</code>
Wordlist : 
<strong>/usr/share/SecLists/Passwords/jwt.secrets.list</strong>
<strong>/usr/share/SecLists/Passwords/scraped-JWT-secrets.txt</strong>
https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-weak-signing-key
Para luego firmar el token usar :  https://jwt.io/</li>
  <li>==Add embedded Header== in attack, change the name to administrator and click sign. Doing this we are sending to the server our public key, the server will use it to validate the token.</li>
  <li>
    <p>==Via kid header path traversal== : The <code class="language-plaintext highlighter-rouge">kid</code> (Key ID) parameter in a JWT header indicates which key the server should use for signature verification. By setting <code class="language-plaintext highlighter-rouge">kid</code> to a path traversal value like <code class="language-plaintext highlighter-rouge">../../../../../../dev/null</code>, we direct the server to look for a verification key in an invalid location. Since <code class="language-plaintext highlighter-rouge">/dev/null</code> is empty, the server fails to retrieve a key. Additionally, we generate a symmetric key with a null byte (<code class="language-plaintext highlighter-rouge">AA==</code> in Base64) and use this key to sign the token. Due to improper key handling, the server may accept the token despite the invalid key, allowing unauthorized access.</p>
  </li>
  <li>==Jku header injection== : Gives the public key with a external link using “jku” header
Exploit server -&gt; craft response with this body (alternative -&gt; using a python server)
{ “keys”: 
[
 {
    <JWT copied="" as="" public="" key="">
 }
]
}
change kid &amp; sub , then click sign in with the RSA generated before.



</JWT>
  </li>
</ol>

      <div class="footer">
        <span class="muted">© 2025 · Generado con Jekyll</span>
      </div>
    </div>
  </main>
</body>
</html>

